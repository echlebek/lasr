package lasr

import (
	"bytes"
	"encoding"
	"encoding/binary"
	"errors"
	"fmt"
	"sync"
	"sync/atomic"
	"time"
)

var (
	// ErrAckNack is returned by Ack and Nack when of them has been called already.
	ErrAckNack = errors.New("lasr: Ack or Nack already called")

	// ErrQClosed is returned by Send, Receive and Close when the Q has already
	// been closed.
	ErrQClosed = errors.New("lasr: Q is closed")

	// ErrOptionsApplied is called when an Option is applied to a Q after NewQ
	// has already returned.
	ErrOptionsApplied = errors.New("lasr: options cannot be applied after New")

	// MaxDelayTime is the maximum time that can be passed to Q.Delay().
	MaxDelayTime = time.Unix(0, 1<<63-1)
)

// ID is used for uniquely identifying messages in a Q.
type ID interface {
	encoding.BinaryMarshaler
}

// Uint64ID is the default ID used by lasr.
type Uint64ID uint64

func (id Uint64ID) MarshalBinary() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 8))
	err := binary.Write(buf, binary.BigEndian, id)
	return buf.Bytes(), err
}

// Message is a messaged returned from Q on Receive.
//
// Message contains a Body and an ID. The ID will be equal to the ID that was
// returned on Send, Delay or Wait for this message.
type Message struct {
	Body []byte
	ID   []byte
	q    *Q
	once int32
	err  error
}

// Sequencer returns an ID with each call to NextSequence and any error
// that occurred.
//
// A Sequencer should obey the following invariants:
//
// * NextSequence is goroutine-safe.
//
// * NextSequence will never generate the same ID.
//
// * NextSequence will return IDs whose big-endian binary representation is incrementing.
//
// Q is not guaranteed to use all of the IDs generated by its Sequencer.
type Sequencer interface {
	NextSequence() (ID, error)
}

// Options can be passed to NewQ.
type Option func(q *Q) error

// WithSequencer will cause a Q to use a user-provided Sequencer.
func WithSequencer(seq Sequencer) Option {
	return func(q *Q) error {
		if q.optsApplied {
			return ErrOptionsApplied
		}
		q.seq = seq
		return nil
	}
}

// WithDeadLetters will cause nacked messages that are not retried to be added
// to a dead letters queue.
func WithDeadLetters() Option {
	return func(q *Q) error {
		if q.optsApplied {
			return ErrOptionsApplied
		}
		q.keys.returned = []byte("deadletters")
		return nil
	}
}

// WithMessageBufferSize sets the message buffer size. By default, the message
// buffer size is 0. Values less than 0 are not allowed.
//
// The buffer is used by Receive to efficiently ready messages for consumption.
// If the buffer is greater than 0, then multiple messages can retrieved in a
// single transaction.
//
// Buffered messages come with a caveat: messages will move into the "unacked"
// state before Receive is called.
//
// Buffered messages come at the cost of increased memory use. If messages are
// large in size, use this cautiously.
func WithMessageBufferSize(size int) Option {
	return func(q *Q) error {
		if q.optsApplied {
			return ErrOptionsApplied
		}
		if size < 0 {
			return fmt.Errorf("lasr: invalid message buffer size: %d", size)
		}
		q.messages = newFifo(size + 1)
		return nil
	}
}

// Ack acknowledges successful receipt and processing of the Message.
func (m *Message) Ack() (err error) {
	if !atomic.CompareAndSwapInt32(&m.once, 0, 1) {
		return ErrAckNack
	}
	return m.q.ack(m.ID)
}

// Nack negatively acknowledges successful receipt and processing of the
// Message. If Nack is called with retry True, then the Message will be
// placed back in the queue in its original position.
func (m *Message) Nack(retry bool) (err error) {
	if !atomic.CompareAndSwapInt32(&m.once, 0, 1) {
		return ErrAckNack
	}
	return m.q.nack(m.ID, retry)
}

// fifo is for buffering received messages
type fifo struct {
	data []*Message
	sync.Mutex
}

func newFifo(size int) *fifo {
	return &fifo{
		data: make([]*Message, 0, size),
	}
}

func (f *fifo) Pop() *Message {
	msg := f.data[0]
	f.data = append(f.data[0:0], f.data[1:]...)
	return msg
}

func (f *fifo) Push(m *Message) {
	if len(f.data) == cap(f.data) {
		panic("push to full buffer")
	}
	f.data = append(f.data, m)
}

func (f *fifo) Len() int {
	return len(f.data)
}

func (f *fifo) Cap() int {
	return cap(f.data)
}

func (f *fifo) SetError(err error) {
	for i := range f.data {
		f.data[i].err = err
	}
}

func (f *fifo) Drain() {
	f.data = f.data[0:0]
}
